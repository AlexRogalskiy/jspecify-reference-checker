atomicreference.must.include.null=expected a @Nullable type argument or else an initial-value constructor argument. The no-arg AtomicReference constructor sets the initial value to null, which is not compatible with %s.
checknotnull=possible null dereference when calling checkNotNull. checkNotNull is annotated to accept only non-null arguments, since it is intended to be used only to check the values of parameters that you have also annotated as non-null. To write a null check of a value that is annotated to possibly be null, use java.util.Objects.requireNonNull instead. (The next 2 error messages are likely to be duplicate reports of this same error. Sorry for the spam.)
dereference=possible null dereference on type %s
enum.constant.annotated=illegal location for annotation: enum constants are always non-null
outer.annotated=illegal location for annotation: outer types are always non-null. To annotate the inner type, write `Foo.@Nullable Bar` instead of `@Nullable Foo.Bar`.
primitive.annotated=illegal location for annotation: primitives are always non-null. To annotate an array of primitives as nullable, write `int @Nullable[]` instead of `@Nullable int[]`.
threadlocal.must.include.null=expected a @Nullable type argument or else an override of initialValue(). Without an override of initialValue(), ThreadLocal.get() may return null, which is not compatible with %s.
type.parameter.annotated=illegal location for annotation: type parameter declarations do not have a nullness. To declare that a type parameter may be instantiated with nullable types, write `T extends @Nullable Object` instead of `@Nullable T`.
wildcard.annotated=illegal location for annotation: wildcard declarations do not have a nullness. To declare that a wildcard may match nullable types, write `? extends @Nullable Object` instead of `@Nullable ?`. Or, in null-aware code, simply write `?`.
